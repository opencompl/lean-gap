import Std.Data.AssocList
import GAP.AST
import GAP.Group


open Std
open GAP.AST
open GAP.Group

-- TODO: consider how to write denotational?
namespace GAP.Semantics

-- 1) SMALLSTEP
-- ============

-- | values 
inductive Val where
| val_perm: Permutation -> Val 
| val_group: GeneratingSet -> Val -- TODO: will we have other representations of groups?
| val_bool: Bool -> Val
| val_int: Int -> Val

open Val
open Expr

-- https://math.stackexchange.com/q/1358030
-- | any odd parity element is generated by 3 cycles.
def val_An (n: Int): Val :=
  val_group $ (List.range n.toNat).map $ 
    fun i => Permutation.mk [(0, 1), (1, 2), (2, n)]

-- | environment
abbrev Env := AssocList String Val


-- | inductive proposition modelling smallstep
inductive StepExpr: Expr -> Val -> Prop := 
| step_expr_int: (i: Int) -> StepExpr (expr_int i) (val_int i)
| step_expr_call_An: (n: Int) -> 
    -- | hacked up notion of alternating group construction
    StepExpr (expr_fn_call "AlternatingGroup" [expr_int n]) (val_An n)
  -- | membership
| step_expr_in: (ep: Expr) 
    -> (egs: Expr)
    -> (p: Permutation)
    -> (gs: GeneratingSet) 
    -> (PVAL: StepExpr ep (val_perm p))
    -> (GSVAL: StepExpr egs (val_group gs))
    -> (member?: Bool)
    -> (MEMBER?: member? = ((generate gs).contains p))
    -> StepExpr (expr_in ep egs)  (val_bool member?)


-- 2) EXECUTABLE
-- ============

-- TODO: how to relate (1) and (2)?
-- Efficient reasoning about executable semantics in Coq:
-- https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.486.1300&rep=rep1&type=pdf
